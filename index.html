<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kitty Speller</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Bubblegum+Sans&family=Fredoka+One&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: 'Bubblegum Sans', cursive;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            background-color: #fdf2f8;
            margin: 0;
            padding: 0;
        }
        .font-brand {
            font-family: 'Fredoka One', cursive;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px); }
            75% { transform: translateX(8px); }
        }
        .animate-shake {
            animation: shake 0.3s ease-in-out;
        }
        * {
            user-select: none;
            -webkit-user-select: none;
        }
    </style>
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@19.0.0",
    "react-dom": "https://esm.sh/react-dom@19.0.0",
    "react-dom/client": "https://esm.sh/react-dom@19.0.0/client",
    "lucide-react": "https://esm.sh/lucide-react@0.475.0?external=react",
    "canvas-confetti": "https://esm.sh/canvas-confetti@1.9.3",
    "react/": "https://esm.sh/react@^19.2.3/",
    "@google/genai": "https://esm.sh/@google/genai@^1.34.0"
  }
}
</script>
</head>
<body class="overflow-hidden">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
import React, { useState, useRef, useCallback, useEffect } from 'react';
import ReactDOM from 'react-dom/client';
import { Play, Volume2, Home, Sparkles, ChevronRight, Lock, Star, FastForward, RotateCcw } from 'lucide-react';
import confetti from 'canvas-confetti';

// --- CONSTANTS ---
const RAW_WORDS = [
  "APPLAUD", "MYTH", "LIFEGUARD", "GOVERNMENT", "LIBRARIES", 
  "HEADACHE", "IMPOSSIBLE", "CONTINUE", "LANGUAGE", "DEFINITION", 
  "WHISPERING", "PARAGRAPH", "INTERPRET", "VULNERABLE", "UNBELIEVABLE", 
  "ACHIEVED", "POPULATION", "TSUNAMI", "SIGNATURE", "ANALYZE", 
  "SYNONYMS", "EARTHQUAKE", "INCREASE", "ENTERTAIN", "SQUEEZE", 
  "WINDSHIELD", "TONGUE", "MIGHTY", "THUNDERSTORM", "SLIPPERY", 
  "SPLURGE", "SCARECROW", "PROGRESSIVE", "MULTIPLY", "BLOSSOM", 
  "WORRIED", "SACRIFICE", "FREIGHT", "CREATURES", "STRENGTH", 
  "ECLIPSE", "DISTANCE", "SURVIVORS", "SCISSORS", "DOUBTFUL", 
  "CLIMAX", "DIALOGUE", "EXERCISE", "STUBBORN", "TRACKSUIT",
  "ENTERTAINMENT", "EQUIPMENT", "EXPERIENCE", "PREFERABLE", "TELEVISION",
  "CELEBRATION", "HUMOROUS", "EXCLAMATION", "IGNORANT", "MEASUREMENT",
  "REQUIREMENT", "DEFINITELY", "INDEPENDENCE", "IMMIGRANT", "INCREDIBLE",
  "COMMUNICATION", "WHISTLING", "EMBARRASSING", "ANXIOUS", "TECHNOLOGY",
  "METROPOLITAN", "MILLIONAIRE", "CHARACTERIZATION", "ANNOUNCEMENT", "LEADERSHIP",
  "EXPRESSION", "NEIGHBORHOOD", "SCIENTIFIC", "THROUGHOUT", "CONDENSATION",
  "MEANWHILE", "UNFORGETTABLE", "TRIUMPH", "EXPENSIVE", "APPEARANCE",
  "POLITELY", "SHIPWRECK", "INGREDIENT", "HERITAGE", "MONUMENTS",
  "DISCIPLINE", "HURRICANE", "INTELLIGENT", "LIGHTNING", "COMPETITION",
  "PRIVILEGE", "CURRICULUM", "ELECTRICITY", "PERSONALITY", "SPECIALIZATION"
];

const WORDS = RAW_WORDS.map(w => ({
  word: w,
  audio: `audio/${w.toLowerCase()}.mp3`
}));

const ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
const WORDS_PER_STAGE = 10;
const EXTRA_TILES_COUNT = 5;

const GameState = {
  START: 'START',
  STAGE_SELECT: 'STAGE_SELECT',
  PLAYING: 'PLAYING',
  CELEBRATING: 'CELEBRATING',
  GAME_OVER: 'GAME_OVER'
};

const COLORS = {
  primary: 'text-purple-600',
  secondary: 'text-pink-500',
  bg: 'bg-pink-100',
  button: 'bg-gradient-to-r from-pink-400 to-purple-400',
};

// --- HELPERS ---
const generateTilePool = (word) => {
  const letters = word.toUpperCase().split('').filter(char => /[A-Z]/.test(char));
  const wordTiles = letters.map((letter, index) => ({
    id: `word-${letter}-${index}-${Math.random().toString(36).substr(2, 9)}`,
    letter,
    isUsed: false,
  }));
  const wordSet = new Set(letters);
  const poolOfExtras = ALPHABET.filter(l => !wordSet.has(l));
  const extraLetters = [];
  for (let i = 0; i < EXTRA_TILES_COUNT; i++) {
    extraLetters.push(poolOfExtras[Math.floor(Math.random() * poolOfExtras.length)]);
  }
  const extraTiles = extraLetters.map((letter, index) => ({
    id: `extra-${letter}-${index}-${Math.random().toString(36).substr(2, 9)}`,
    letter,
    isUsed: false,
  }));
  return [...wordTiles, ...extraTiles].sort(() => Math.random() - 0.5);
};

// --- COMPONENTS ---
const KittyMascot = ({ className }) => (
  <svg viewBox="0 0 200 200" className={className} xmlns="http://www.w3.org/2000/svg">
    <circle cx="100" cy="110" r="70" fill="#fbcfe8" />
    <path d="M50 70 L30 20 L80 50 Z" fill="#fbcfe8" />
    <path d="M150 70 L170 20 L120 50 Z" fill="#fbcfe8" />
    <circle cx="75" cy="100" r="8" fill="#4c1d95" />
    <circle cx="125" cy="100" r="8" fill="#4c1d95" />
    <path d="M90 120 Q100 135 110 120" stroke="#4c1d95" strokeWidth="4" fill="none" strokeLinecap="round" />
    <circle cx="100" cy="115" r="5" fill="#ec4899" />
    <path d="M100 125 L100 145" stroke="#4c1d95" strokeWidth="2" strokeDasharray="2,2" />
  </svg>
);

const App = () => {
  const [gameState, setGameState] = useState(GameState.START);
  const [currentStageIdx, setCurrentStageIdx] = useState(0);
  const [currentWordInStageIdx, setCurrentWordInStageIdx] = useState(0);
  const [userTyped, setUserTyped] = useState('');
  const [tilePool, setTilePool] = useState([]);
  const [mistakes, setMistakes] = useState(0);
  const [startTime, setStartTime] = useState(0);
  const [sessionHistory, setSessionHistory] = useState([]);
  const [shake, setShake] = useState(false);
  
  const [stagesProgress, setStagesProgress] = useState(() => {
    const saved = localStorage.getItem('kitty_speller_progress');
    if (saved) return JSON.parse(saved);
    return Array.from({ length: 10 }, (_, i) => ({
      stars: 0,
      isUnlocked: i === 0,
      correctCount: 0
    }));
  });

  const audioRef = useRef(null);

  useEffect(() => {
    localStorage.setItem('kitty_speller_progress', JSON.stringify(stagesProgress));
  }, [stagesProgress]);

  const globalWordIdx = (currentStageIdx * WORDS_PER_STAGE) + currentWordInStageIdx;
  const currentWord = WORDS[globalWordIdx]?.word.toUpperCase() || '';

  const playWordAudio = useCallback((idx) => {
    const wordData = WORDS[idx];
    if (!wordData) return;

    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.src = wordData.audio;
      audioRef.current.load();
      audioRef.current.play().catch((err) => {
        console.warn(`Could not play audio for ${wordData.word}:`, err.message);
      });
    }
  }, []);

  const initRound = useCallback((stageIdx, wordInStageIdx) => {
    const globalIdx = (stageIdx * WORDS_PER_STAGE) + wordInStageIdx;
    if (globalIdx >= WORDS.length || wordInStageIdx >= WORDS_PER_STAGE) {
      setGameState(GameState.GAME_OVER);
      return;
    }
    setTilePool(generateTilePool(WORDS[globalIdx].word.toUpperCase()));
    setUserTyped('');
    setMistakes(0);
    setStartTime(Date.now());
    setGameState(GameState.PLAYING);
    setTimeout(() => playWordAudio(globalIdx), 600);
  }, [playWordAudio]);

  const handleStageEnd = () => {
    const correctCount = sessionHistory.filter(h => !h.skipped).length;
    let stars = 0;
    if (correctCount === 10) stars = 3;
    else if (correctCount >= 7) stars = 2;
    else if (correctCount >= 3) stars = 1;

    setStagesProgress(prev => {
      const next = [...prev];
      if (stars > next[currentStageIdx].stars) next[currentStageIdx].stars = stars;
      next[currentStageIdx].correctCount = Math.max(next[currentStageIdx].correctCount, correctCount);
      if (stars >= 1 && currentStageIdx < 9) next[currentStageIdx + 1].isUnlocked = true;
      return next;
    });
    setGameState(GameState.GAME_OVER);
  };

  const handleWin = () => {
    confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 }, colors: ['#f472b6', '#a855f7', '#ec4899'] });
    setSessionHistory(prev => [...prev, { word: currentWord, mistakes, timeSpent: Math.round((Date.now() - startTime) / 1000), skipped: false }]);
    setGameState(GameState.CELEBRATING);
  };

  const skipWord = () => {
    setSessionHistory(prev => [...prev, { word: currentWord, mistakes: 0, timeSpent: 0, skipped: true }]);
    const nextIdx = currentWordInStageIdx + 1;
    if (nextIdx < WORDS_PER_STAGE) {
      setCurrentWordInStageIdx(nextIdx);
      initRound(currentStageIdx, nextIdx);
    } else {
      handleStageEnd();
    }
  };

  const nextWord = () => {
    const nextIdx = currentWordInStageIdx + 1;
    if (nextIdx < WORDS_PER_STAGE) {
      setCurrentWordInStageIdx(nextIdx);
      initRound(currentStageIdx, nextIdx);
    } else {
      handleStageEnd();
    }
  };

  const selectStage = (idx) => {
    if (!stagesProgress[idx].isUnlocked) return;
    setCurrentStageIdx(idx);
    setCurrentWordInStageIdx(0);
    setSessionHistory([]);
    initRound(idx, 0);
  };

  const handleTileClick = (tile) => {
    if (gameState !== GameState.PLAYING || tile.isUsed) return;
    if (tile.letter === currentWord[userTyped.length]) {
      const nextTyped = userTyped + tile.letter;
      setUserTyped(nextTyped);
      setTilePool(prev => prev.map(t => t.id === tile.id ? { ...t, isUsed: true } : t));
      if (nextTyped === currentWord) handleWin();
    } else {
      setMistakes(prev => prev + 1);
      setShake(true);
      setTimeout(() => setShake(false), 500);
    }
  };

  return (
    <div className={`min-h-screen ${COLORS.bg} p-4 sm:p-8 overflow-x-hidden`}>
      <audio ref={audioRef} />
      <main className="max-w-5xl mx-auto min-h-[85vh] flex items-center justify-center">
        {gameState === GameState.START && (
          <div className="flex flex-col items-center text-center space-y-8 animate-in fade-in zoom-in duration-500">
            <KittyMascot className="w-48 h-48 drop-shadow-xl" />
            <div className="space-y-4">
              <h1 className={`text-6xl font-extrabold ${COLORS.primary} font-brand tracking-tight`}>Kitty Spells</h1>
              <p className={`text-2xl ${COLORS.secondary} font-medium`}>Ready to earn some stars?</p>
            </div>
            <button onClick={() => setGameState(GameState.STAGE_SELECT)} className={`${COLORS.button} text-white px-12 py-6 rounded-full text-3xl font-bold font-brand shadow-2xl hover:scale-105 active:scale-95 transition-transform flex items-center gap-4`}>
              <Play fill="currentColor" className="w-10 h-10" /> GO TO STAGES
            </button>
          </div>
        )}

        {gameState === GameState.STAGE_SELECT && (
          <div className="flex flex-col items-center w-full max-w-5xl mx-auto space-y-10 py-8 animate-in fade-in slide-in-from-bottom-8">
            <h2 className="text-5xl font-brand text-purple-700">Pick a Stage</h2>
            <div className="grid grid-cols-2 md:grid-cols-5 gap-6 w-full px-4">
              {stagesProgress.map((prog, i) => (
                <div key={i} className="flex flex-col items-center space-y-3">
                  <button onClick={() => selectStage(i)} disabled={!prog.isUnlocked} className={`w-full aspect-square rounded-3xl flex flex-col items-center justify-center relative transition-all shadow-lg ${prog.isUnlocked ? 'bg-white hover:scale-105 border-b-8 border-purple-200' : 'bg-gray-200 opacity-60'}`}>
                    {!prog.isUnlocked ? <Lock className="w-12 h-12 text-gray-400" /> : <span className="text-4xl font-brand text-purple-600">{i + 1}</span>}
                  </button>
                  <div className="flex gap-1 h-6">
                    {prog.isUnlocked && Array.from({ length: 3 }).map((_, s) => <Star key={s} size={20} className={s < prog.stars ? "fill-yellow-400 text-yellow-500" : "text-gray-300 fill-gray-100"} />)}
                  </div>
                </div>
              ))}
            </div>
            <button onClick={() => setGameState(GameState.START)} className="flex items-center gap-2 text-purple-500 font-bold hover:text-pink-600 transition-colors"><Home /> Main Menu</button>
          </div>
        )}

        {gameState === GameState.PLAYING && (
          <div className={`flex flex-col items-center space-y-12 w-full max-w-4xl mx-auto ${shake ? 'animate-shake' : ''}`}>
            <div className="flex justify-between w-full px-6 py-4 bg-white/50 backdrop-blur-sm rounded-2xl border border-pink-200 items-center">
              <div className="flex flex-col">
                <span className="text-xs font-bold text-pink-400 uppercase tracking-tighter">Stage {currentStageIdx + 1}</span>
                <span className="font-brand text-2xl text-purple-700">Word {currentWordInStageIdx + 1} / 10</span>
              </div>
              <button onClick={skipWord} className="px-4 py-2 rounded-xl bg-purple-100 text-purple-600 font-bold border border-purple-200 text-sm flex items-center gap-2 hover:bg-purple-200 transition-colors">
                Skip <FastForward size={16} />
              </button>
            </div>
            <div className="flex flex-col items-center gap-6">
              <div className="relative">
                <KittyMascot className="w-32 h-32" />
                <button onClick={() => playWordAudio(globalWordIdx)} className="absolute -bottom-2 -right-2 p-4 bg-white rounded-full shadow-xl text-purple-600 hover:text-pink-500 hover:scale-110 transition-all border-2 border-purple-100">
                  <Volume2 />
                </button>
              </div>
              <div className="flex gap-2 flex-wrap justify-center min-h-[80px]">
                {currentWord.split('').map((char, i) => (
                  <div key={i} className={`w-12 h-16 border-b-4 flex items-center justify-center text-4xl font-brand transition-all ${userTyped[i] ? 'border-pink-500 text-purple-700 bg-pink-50' : 'border-gray-300 text-transparent bg-white/30'}`}>
                    {userTyped[i] || ''}
                  </div>
                ))}
              </div>
            </div>
            <div className="grid grid-cols-4 sm:grid-cols-5 md:grid-cols-6 gap-3 p-6 bg-white/40 rounded-3xl shadow-inner">
              {tilePool.map((tile) => (
                <button key={tile.id} onClick={() => handleTileClick(tile)} disabled={tile.isUsed} className={`w-14 h-14 sm:w-16 sm:h-16 flex items-center justify-center text-3xl font-brand rounded-2xl shadow-lg transition-all ${tile.isUsed ? 'bg-gray-200 text-gray-400 scale-90 opacity-40 shadow-none' : 'bg-white text-purple-600 hover:-translate-y-1 hover:shadow-xl active:scale-95 border-b-4 border-purple-100'}`}>
                  {tile.letter}
                </button>
              ))}
            </div>
            <button onClick={() => setGameState(GameState.STAGE_SELECT)} className="font-bold text-purple-400 hover:text-pink-600">Quit to Stages</button>
          </div>
        )}

        {gameState === GameState.CELEBRATING && (
          <div className="text-center space-y-6 animate-in zoom-in">
            <KittyMascot className="w-48 h-48 mx-auto" />
            <div className="space-y-2">
              <h2 className="text-5xl font-brand text-pink-500">PAW-SOME!</h2>
              <p className="text-6xl font-brand text-purple-700 tracking-widest">{currentWord}</p>
            </div>
            <button onClick={nextWord} className={`${COLORS.button} text-white px-12 py-5 rounded-full text-2xl font-brand shadow-2xl hover:scale-105 transition-transform flex items-center gap-3 mx-auto`}>
              NEXT WORD <ChevronRight size={28} />
            </button>
          </div>
        )}

        {gameState === GameState.GAME_OVER && (
          <div className="text-center space-y-8 animate-in fade-in">
            <h2 className="text-5xl font-brand text-purple-700">Stage {currentStageIdx + 1} Complete!</h2>
            <div className="flex justify-center gap-4 py-4">
              {Array.from({ length: 3 }).map((_, s) => {
                const correctCount = sessionHistory.filter(h => !h.skipped).length;
                let earned = false;
                if (s === 0 && correctCount >= 3) earned = true;
                if (s === 1 && correctCount >= 7) earned = true;
                if (s === 2 && correctCount === 10) earned = true;
                return <Star key={s} size={80} className={`drop-shadow-lg ${earned ? "fill-yellow-400 text-yellow-500" : "text-gray-200 fill-gray-50"}`} />;
              })}
            </div>
            <p className="text-2xl font-brand text-pink-500">You got {sessionHistory.filter(h => !h.skipped).length} / 10 words!</p>
            <div className="flex flex-col gap-4 w-64 mx-auto">
              <button onClick={() => {
                setCurrentWordInStageIdx(0);
                setSessionHistory([]);
                initRound(currentStageIdx, 0);
              }} className={`${COLORS.button} text-white px-10 py-5 rounded-full text-xl font-brand shadow-xl flex items-center justify-center gap-2`}><RotateCcw size={20} /> TRY AGAIN</button>
              <button onClick={() => setGameState(GameState.STAGE_SELECT)} className="bg-white text-purple-600 border-4 border-purple-100 px-10 py-5 rounded-full text-xl font-brand">BACK TO STAGES</button>
            </div>
          </div>
        )}
      </main>
    </div>
  );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
    </script>
</body>
</html>